---
title: "Carto_pneu_remedy"
author: "Ibrahima SOW"
date: "12/14/2020"
output: html_document
---


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(readr)
library(data.table)
library(stringr)
```

## Second passage
```{r}
sensor_df <- fread("P2/sensor_1.csv", header = F, quote = "")
names(sensor_df)[1] <- "sensor_id"
names(sensor_df)[2] <- "sensor_time"
names(sensor_df)[3] <- "value"
sensor_df
``` 


```{r}
sensor_df$sensor_id <- substr(sensor_df$sensor_id, 14, 14)

sensor_df$sensor_time <- substr(sensor_df$sensor_time, 16, 39)
sensor_df$sensor_time <- gsub("T", " ", sensor_df$sensor_time)

sensor_df$value <- substr(sensor_df$value, 10, 14)

sensor_df$value <- gsub("\"", "", sensor_df$value)
sensor_df$value <- gsub("}", "", sensor_df$value)

options(digits.secs = 3) 

sensor_df$sensor_time <- as.POSIXct(sensor_df$sensor_time)

sensor_df$value <- as.numeric(sensor_df$value)
  
#sensor_1_P2$sensor_time <- gsub("Z", "", sensor_1_P2$sensor_time)
sensor_df
```

## Importing simple log files  

```{r message=FALSE, warning=FALSE}
#simple_log_P1 <- fread("P1/simple-log.txt",  header = F)
logs <- fread("P2/simple-log.txt",  header = F)

#simple_log_P1$V1 <- substr(simple_log_P1$V1, 1, 23)
logs$V1 <- substr(logs$V1, 1, 27)

names(logs)[1] <- "date_time"
names(logs)[2] <- "date_gnss"
names(logs)[3] <- "heure_gnss"
names(logs)[4] <- "latitude"
names(logs)[5] <- "longitude"
names(logs)[6] <- "speed"

logs$date_time <-as.POSIXct(logs$date_time, format="%Y-%m-%d %H:%M:%OS")

#simple_log_P2$date_time <- format(simple_log_P2$date_time,)
logs <- logs[!is.na(logs$latitude) &
                                 !is.na(logs$longitude), ] %>%
        subset(select = -c(date_gnss, heure_gnss))
logs
```

## Roads/Fields segmentation

```{r message=FALSE, warning=FALSE}
fields <- fread("P2/GIS_parcelles_soil_type_added.csv");fields
roads <- fread("P2/roads_p2.csv");roads
```

### ROADS
#### Roads pre-processing

```{r}
names(roads)[1] <- "date_time"
names(roads)[2] <- "date_gnss"
names(roads)[3] <- "time_gnss"
names(roads)[4] <- "latitude"
names(roads)[5] <- "longitude"
names(roads)[6] <- "speed"
names(roads)[7] <- "road_sections"

roads$road_sections <- gsub("portion", "", roads$road_sections) %>%
                        as.numeric()

roads$date_time <- as.POSIXct(roads$date_time)

roads
```

```{r}
roads$round <- "aller"
roads[1185:nrow(roads),8] <- "retour" # 1184 index -> début retour
roads
```

```{r}
min(roads$date_time);max(roads$date_time) # aller/retours (not that informative)
```

#### Roads query fun 
```{r}
# Segmentation par requêtes - aller 1 ici 
roads_querer <- function (section, round_type){ # OUi oui querer
  
  # Subsetting the roads dataset 
  aller_1 <- roads[roads$road_sections == section & roads$round==round_type ,]
  
  # Using logs subset to subset sensor data 
  sensor_df_p2 <- sensor_df[sensor_df$sensor_time >= min(aller_1$date_time) &
                          sensor_df$sensor_time <= max(aller_1$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- sensor_df_p2
  roads_logs <- roads
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > aller_1$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = aller_1$latitude[j]
      subset_sensor$long[i] = aller_1$longitude[j]
      subset_sensor$speed[i] = aller_1$speed[j]
      subset_sensor$road_sections[i] = aller_1$road_sections[j]
      subset_sensor$round[i] = aller_1$round[j]
    #print(i) debugging tool, if needed 
  }
  return(subset_sensor)
}

road_sec <- roads_querer(2, "aller")
road_sec
```
#### Roads mapping

```{r}
library(viridis)
library(leaflet)
domain <- range(road_sec$value)

# make palette
pal <- colorNumeric(palette = viridis(3), domain = domain)
```

 
```{r}
roads_map <- leaflet(road_sec) %>% 
                addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
                options = providerTileOptions(noWrap = TRUE)) %>%
                addCircleMarkers(radius = ~(value-350), color = ~pal(value), 
                                fillColor = ~pal(value), opacity = 0.2,
                                label = paste(road_sec$value)) 

roads_map
```

<<<<<<< HEAD
-------------------
 
Val's 

```{r}
road_sec$value
library(quantmod)
maxindex=findPeaks(road_sec$value[30:200])
minindex=findValleys(road_sec$value[30:200])
```

```{r}
minmax=data.frame(value=road_sec$value)
minmax$min=0
minmax$max=0
minmax$min[minindex]=1
minmax$max[maxindex]=1
```

-------------------


### FIELDS 
#### Fields pre-processing

#### Fields pre-processing

```{r}
names(fields)[1] <- "date_time"
names(fields)[2] <- "date_gnss"
names(fields)[3] <- "time_gnss"
names(fields)[4] <- "latitude"
names(fields)[5] <- "longitude"
names(fields)[6] <- "speed"
names(fields)[7] <- "field_id"
names(fields)[8] <- "soil_type"

fields$date_time <- as.POSIXct(fields$date_time)

fields$speed <- gsub(",", ".", fields$speed) %>%
                as.numeric()
fields$longitude <- gsub(",", ".", fields$longitude) %>%
                as.numeric()
fields
```

```{r}
min(fields$date_time);max(fields$date_time) # Aller/retours considerated - not informative !!!
```

#### Fields query fun 

```{r}
# Subsetting the roads dataset 
fields_querer <- function (fieldId){ # Oui oui querer 
  field <- fields[fields$field_id == fieldId,]

  # Using logs subset to subset sensor data 
  subseted_sensor <- sensor_df[sensor_df$sensor_time >= min(field$date_time) &
                          sensor_df$sensor_time <= max(field$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- subseted_sensor
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > field$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = field$latitude[j]
      subset_sensor$long[i] = field$longitude[j]
      subset_sensor$vitesse[i] = field$speed[j]
      subset_sensor$field_id[i] = field$field_id[j]
      subset_sensor$soil_type[i] = field$soil_type[j]
      print(i) #debugging tool, if needed !!!
  }
  return(subset_sensor)
}

def_field <- fields_querer(1) # Querying field 1 
#def_field <- subset_sensor ### A éliminer dès relance boucle 
min(def_field$value);max(def_field$value)
```

#### Fields Mapping

```{r message=FALSE, warning=FALSE}
library(viridis)
library(leaflet)
domain <- range(def_field$value)

# make palette
pal <- colorNumeric(palette = viridis(3), domain = domain)
soil_rasters <- raster("classif_sol.tif",prefer_proj = epsg3857)
rasters_pal <- colorNumeric(c("#43A9F2", "#F1D674", "#F46C6A"), values(soil_rasters),na.color = "transparent")
```

 
```{r}

fields_map <- leaflet(def_field) %>% addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
                      options = providerTileOptions(noWrap = TRUE),  group = "Basic Layer(default)") %>%
                addCircleMarkers(radius = ~(value-330), color = ~pal(value), 
                        fillColor = ~pal(value), opacity = 0.2,
                        label = paste0(def_field$value, " - " ,def_field$soil_type), group = "Values") %>%
                addRasterImage(soil_rasters, colors = rasters_pal, opacity = 0.8, group = "Soil types") %>%
                addLegend(position = "topright",colors = c("#43A9F2", "#F1D674", "#F46C6A"),
                         labels = c("Argileux","Moyen","Caillouteux"), opacity = 0.8,title = "Soil type classification", 
                          group = "Soil types") %>%
                addLayersControl(baseGroups = c("Basic Layer (default)"),
                                 overlayGroups = c("Values","Soil types"),
                                 position = "topleft",options = layersControlOptions(collapsed = T)
  )
fields_map
```


## Comments and suggestions 

- Min/Max locaux avec dérivés 
- XXX
- Histogramme // 2 sortes de pics 


- largeur pic : vitesse (intervale pic) // compensation de la perte de données due à la déformation 
- graphes de validation 

- this first step : bruit créer par le dispositif (caractériser stabilité dans le temps de ces indicateurs/ est-ce influencé par les variations d'altitudes, chngmnt de rang / aller-retour) 
   // graph maxi-amplitudes-bien conprendre leur variabilité- séparation route/parcelles-axé sur montrer la variabilité soit par type de revêtement soit par structure spatiale dans les rangs 
   // classification des valeurs par vitesses (mettre route VS parcelles) -> faire des classes de vitesses bien disjointes

- after : est-ce que intensité variation de poids générée par la charge est masquée ou pas. 




