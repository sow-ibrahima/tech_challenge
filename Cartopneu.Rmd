---
title: "Carto_pneu_remedy"
author: "Ibrahima SOW"
date: "12/14/2020"
output: html_document
---


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(readr)
library(data.table)
library(stringr)
```

## Second passage
```{r}
sensor_df <- fread("P2/sensor_1.csv", header = F, quote = "")
names(sensor_df)[1] <- "sensor_id"
names(sensor_df)[2] <- "sensor_time"
names(sensor_df)[3] <- "value"
sensor_df
``` 


```{r}
sensor_df$sensor_id <- substr(sensor_df$sensor_id, 14, 14)

sensor_df$sensor_time <- substr(sensor_df$sensor_time, 16, 39)
sensor_df$sensor_time <- gsub("T", " ", sensor_df$sensor_time)

sensor_df$value <- substr(sensor_df$value, 10, 14)

sensor_df$value <- gsub("\"", "", sensor_df$value)
sensor_df$value <- gsub("}", "", sensor_df$value)

my_options <- options(digits.secs = 3) 

sensor_df$sensor_time <- as.POSIXct(sensor_df$sensor_time)

sensor_df$value <- as.numeric(sensor_df$value)
  
#sensor_1_P2$sensor_time <- gsub("Z", "", sensor_1_P2$sensor_time)
sensor_df
```

## Importing simple log files  

```{r message=FALSE, warning=FALSE}
#simple_log_P1 <- fread("P1/simple-log.txt",  header = F)
simple_log_P2 <- fread("P2/simple-log.txt",  header = F)

#simple_log_P1$V1 <- substr(simple_log_P1$V1, 1, 23)
simple_log_P2$V1 <- substr(simple_log_P2$V1, 1, 27)

names(simple_log_P2)[1] <- "date_time"
names(simple_log_P2)[2] <- "date_gnss"
names(simple_log_P2)[3] <- "heure_gnss"
names(simple_log_P2)[4] <- "latitude"
names(simple_log_P2)[5] <- "longitude"
names(simple_log_P2)[6] <- "speed"

simple_log_P2$date_time <-as.POSIXct(simple_log_P2$date_time, format="%Y-%m-%d %H:%M:%OS")

#simple_log_P2$date_time <- format(simple_log_P2$date_time,)
simple_log_P2
```


```{r}
logs <- simple_log_P2[!is.na(simple_log_P2$latitude) &
                                 !is.na(simple_log_P2$longitude), ] %>%
        subset(select = -c(date_gnss, heure_gnss))
logs
```

## Val's

```{r message=FALSE, warning=FALSE}
fields <- fread("P2/GIS_parcelles_soil_type_added.csv");fields
roads <- fread("P2/roads_p2.csv");roads
```

```{r}
names(fields)[1] <- "date_time"
names(roads)[1] <- "date_time"

names(fields)[2] <- "date_gnss"
names(roads)[2] <- "date_gnss"
  
names(fields)[3] <- "time_gnss"
names(roads)[3] <- "time_gnss"

names(fields)[4] <- "latitude"
names(roads)[4] <- "latitude"

names(fields)[5] <- "longitude"
names(roads)[5] <- "longitude"

names(fields)[6] <- "speed"
names(roads)[6] <- "speed"

names(fields)[7] <- "field_id"
names(roads)[7] <- "road_sections"

names(fields)[8] <- "soil_type"

roads$road_sections <- gsub("portion", "", roads$road_sections) %>%
                        as.numeric()

table(fields$field_id)
fields
roads
```

```{r}
fields$date_time <- as.POSIXct(fields$date_time)
roads$date_time <- as.POSIXct(roads$date_time)
```

```{r}
roads$round <- "aller"
roads[1185:nrow(roads),8] <- "retour" # 1184 index -> début retour
roads
```

```{r}
min(fields$date_time);max(fields$date_time)
```

```{r}
min(roads$date_time);max(roads$date_time)
```

```{r}
# Segmentation par requêtes - aller 1 ici 

query <- function (section, round_type){
  
  # Subsetting the roads dataset 
  aller_1 <- roads[roads$road_sections == section & roads$round==round_type ,]
  
  # Using logs subset to subset sensor data 
  sensor_df_p2 <- sensor_df[sensor_df$sensor_time >= min(aller_1$date_time) &
                          sensor_df$sensor_time <= max(aller_1$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- sensor_df_p2
  roads_logs <- roads
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > logs$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = logs$latitude[j]
      subset_sensor$long[i] = logs$longitude[j]
      subset_sensor$vitesse[i] = logs$speed[j]
    #print(i) debugging tool, if needed 
  }
  return(subset_sensor)
}

xyz <- query(2, "aller")
xyz
```

```{r}
query <- function (field_id){
  
  # Subsetting the roads dataset 
  field <- fields[fields$field_id == section,]
  
  # Using logs subset to subset sensor data 
  sensor_df_p2 <- sensor_df[sensor_df$sensor_time >= min(field$date_time) &
                          sensor_df$sensor_time <= max(field$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- sensor_df_p2
  roads_logs <- roads
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > logs$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = logs$latitude[j]
      subset_sensor$long[i] = logs$longitude[j]
      subset_sensor$vitesse[i] = logs$speed[j]
    #print(i) debugging tool, if needed 
  }
  return(subset_sensor)
}

# Subsetting the roads dataset 
field <- fields[fields$field_id == 43,]

# Using logs subset to subset sensor data 
sensor_df_p2 <- sensor_df[sensor_df$sensor_time >= min(field$date_time) &
                        sensor_df$sensor_time <= max(field$date_time),]

# Changing df names (for secure)
subset_sensor <- sensor_df_p2[1:20000, ]
roads_logs <- roads

# While statement to affect lats/longs and speed to dedicated timestamps
j=1
for(i in 1:nrow(subset_sensor)) {
  while(subset_sensor$sensor_time[i] > logs$date_time[j]) {
    j=j+1
  }
    subset_sensor$lat[i] = logs$latitude[j]
    subset_sensor$long[i] = logs$longitude[j]
    subset_sensor$vitesse[i] = logs$speed[j]
  print(i) #debugging tool, if needed 
}

min(subset_sensor$value);max(subset_sensor$value)
```

```{r}
library(viridis)
library(leaflet)
domain <- range(subset_sensor$value)

# make palette
pal <- colorNumeric(palette = viridis(3), domain = domain)
```

 
```{r}

map <- leaflet(subset_sensor) %>% addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
                      options = providerTileOptions(noWrap = TRUE)) %>%
       addCircleMarkers(radius = ~(value-300), color = ~pal(value), 
                        fillColor = ~pal(value), opacity = 0.2,
                        label = paste(subset_sensor$value))
map
```



## Plot_ly 

```{r}
library(plotly)
mysensor_df$date_time <- as.POSIXct(mysensor_df$date_time)
```

```{r}
fg <- plot_ly(x=~mysensor_df$date_time, y=mysensor_df$value, alpha = 0.4,
              mode = 'markers', text = paste("days from today"))
fg
```

```{r message=FALSE, warning=FALSE}
my_parcelles <- read_csv("P2/GIS_parcelles.csv");my_parcelles
roads <- fread("P2/roads_p2.csv");roads
```

```{r}
names(my_parcelles)[1] <- "date_time"
names(roads)[1] <- "date_time"
  
names(my_parcelles)[2] <- "date_gnss"
names(roads)[2] <- "date_gnss"
  
names(my_parcelles)[3] <- "time_gnss"
names(roads)[3] <- "time_gnss"

names(my_parcelles)[4] <- "time_gnss"
names(roads)[4] <- "time_gnss"

names(my_parcelles)[5] <- "time_gnss"
names(roads)[5] <- "time_gnss"

names(my_parcelles)[6] <- "time_gnss"
names(roads)[6] <- "time_gnss"

table(my_parcelles$`ID Culture`)
roads
```

```{r}
mysensor_df$date_time <- as.character(mysensor_df$date_time)
my_parcelles$date_time <- as.character(my_parcelles$date_time)
```

```{r}
join_parcelles <- merge(mysensor_df, my_parcelles, by="date_time")
table(join_parcelles$`ID Culture`)
```



```{r}
join_parcelles$date_time <- as.POSIXct(join_parcelles$date_time)

fg <- plot_ly(x=~join_parcelles$date_time, y=~join_parcelles$value, alpha = 0.4,
              colors = ~join_parcelles$`ID Culture`,
              mode = 'lines', text = paste("days from today"))
fg
```

- Min/Max locaux avec dérivés 
- XXX
- Histogramme // 2 sortes de pics 
```{r}
library(pspline)
deriv_x <- predict(sm.spline(join_parcelles$date_time, as.numeric(join_parcelles$value)), time, 1)
```


```{r}
library(xts)
d1 <- xts(splinefun(join_parcelles$date_time, join_parcelles$value)(join_parcelles$date_time, 1), join_parcelles$date_time)
sensor_df <- cbind(join_parcelles, d1)

sensor_df$value <- as.numeric(sensor_df$value)
sensor_df$date_time <- as.POSIXct(sensor_df$date_time)

fg <- plot_ly(x=~sensor_df$date_time, y=~sensor_df$value, alpha = 0.4,
              mode = 'lines', text = paste("days from today"))
fg
fg1 <- plot_ly(x=~sensor_df$date_time, y=~sensor_df$value, alpha = 0.4,
              mode = 'lines', text = paste("days from today"))

fg1
```

```{r}
roads
```


```{r}
library(pracma)
sensor_df$value <- as.numeric(sensor_df$value)
pracma::findpeaks(as.numeric(sensor_df[1:100,]$value))
```

```{r}
subset_sensor_df <- sensor_df[1:100,]

subset_sensor_df$sensor_time <- as.POSIXct(subset_sensor_df$sensor_time)
subset_sensor_df$sensor_time <- format(subset_sensor_df$sensor_time,"%Y-%m-%d %H:%M:%OS3")

fg <- plot_ly(x=~subset_sensor_df$sensor_time, y=~subset_sensor_df$value, alpha = 0.4,
              mode = 'markers', text = paste("days from today"))
fg  %>%
layout(paper_bgcolor='#5875D5',
       plot_bgcolor='#5875D5')
fg
```

- largeur pic : vitesse (intervale pic) // compensation de la perte de données due à la déformation 
- graphes de validation 

- this first step : bruit créer par le dispositif (caractériser stabilité dans le temps de ces indicateurs/ est-ce influencé par les variations d'altitudes, chngmnt de rang / aller-retour) 
   // graph maxi-amplitudes-bien conprendre leur variabilité- séparation route/parcelles-axé sur montrer la variabilité soit par type de revêtement soit par structure spatiale dans les rangs 
   // classification des valeurs par vitesses (mettre route VS parcelles) -> faire des classes de vitesses bien disjointes

- after : est-ce que intensité variation de poids générée par la charge est masquée ou pas. 



