---
title: "Carto_pneu_remedy"
author: "Ibrahima SOW"
date: "12/14/2020"
output: html_document
---


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(readr)
library(data.table)
library(stringr)
```

## Second passage
```{r}
sensor_df <- fread("P2/sensor_1.csv", header = F, quote = "")
names(sensor_df)[1] <- "sensor_id"
names(sensor_df)[2] <- "sensor_time"
names(sensor_df)[3] <- "value"
sensor_df
``` 


```{r}
sensor_df$sensor_id <- substr(sensor_df$sensor_id, 14, 14)

sensor_df$sensor_time <- substr(sensor_df$sensor_time, 16, 39)
sensor_df$sensor_time <- gsub("T", " ", sensor_df$sensor_time)

sensor_df$value <- substr(sensor_df$value, 10, 14)

sensor_df$value <- gsub("\"", "", sensor_df$value)
sensor_df$value <- gsub("}", "", sensor_df$value)

options(digits.secs = 3) 

sensor_df$sensor_time <- as.POSIXct(sensor_df$sensor_time)

sensor_df$value <- as.numeric(sensor_df$value)
  
#sensor_1_P2$sensor_time <- gsub("Z", "", sensor_1_P2$sensor_time)
sensor_df
```

## Importing simple log files  

```{r message=FALSE, warning=FALSE}
#simple_log_P1 <- fread("P1/simple-log.txt",  header = F)
logs <- fread("P2/simple-log.txt",  header = F)

#simple_log_P1$V1 <- substr(simple_log_P1$V1, 1, 23)
logs$V1 <- substr(logs$V1, 1, 27)

names(logs)[1] <- "date_time"
names(logs)[2] <- "date_gnss"
names(logs)[3] <- "heure_gnss"
names(logs)[4] <- "latitude"
names(logs)[5] <- "longitude"
names(logs)[6] <- "speed"

logs$date_time <-as.POSIXct(logs$date_time, format="%Y-%m-%d %H:%M:%OS")

#simple_log_P2$date_time <- format(simple_log_P2$date_time,)
logs <- logs[!is.na(logs$latitude) &
                                 !is.na(logs$longitude), ] %>%
        subset(select = -c(date_gnss, heure_gnss))
logs
```

## Roads/Fields segmentation

```{r message=FALSE, warning=FALSE}
fields <- fread("P2/GIS_parcelles_soil_type_added.csv");fields
roads <- fread("P2/roads_p2.csv");roads
```


### Roads pre-processing

```{r}
names(roads)[1] <- "date_time"
names(roads)[2] <- "date_gnss"
names(roads)[3] <- "time_gnss"
names(roads)[4] <- "latitude"
names(roads)[5] <- "longitude"
names(roads)[6] <- "speed"
names(roads)[7] <- "road_sections"

roads$road_sections <- gsub("portion", "", roads$road_sections) %>%
                        as.numeric()

roads$date_time <- as.POSIXct(roads$date_time)

roads
```

```{r}
roads$round <- "aller"
roads[1185:nrow(roads),8] <- "retour" # 1184 index -> début retour
roads
```

```{r}
min(roads$date_time);max(roads$date_time) # aller/retours (not that informative)
```

### Roads query fun 
```{r}
# Segmentation par requêtes - aller 1 ici 
roads_querer <- function (section, round_type){ # OUi oui querer
  
  # Subsetting the roads dataset 
  aller_1 <- roads[roads$road_sections == section & roads$round==round_type ,]
  
  # Using logs subset to subset sensor data 
  sensor_df_p2 <- sensor_df[sensor_df$sensor_time >= min(aller_1$date_time) &
                          sensor_df$sensor_time <= max(aller_1$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- sensor_df_p2
  roads_logs <- roads
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > logs$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = logs$latitude[j]
      subset_sensor$long[i] = logs$longitude[j]
      subset_sensor$speed[i] = logs$speed[j]
    #print(i) debugging tool, if needed 
  }
  return(subset_sensor)
}

road_sec <- roads_querer(2, "aller")
road_sec
```
### Roads mapping

```{r}
library(viridis)
library(leaflet)
domain <- range(road_sec$value)

# make palette
pal <- colorNumeric(palette = viridis(3), domain = domain)
```

 
```{r}
roads_map <- leaflet(road_sec) %>% 
             addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
             options = providerTileOptions(noWrap = TRUE)) %>%
  
                 addCircleMarkers(radius = ~(value-350), color = ~pal(value), 
                        fillColor = ~pal(value), opacity = 0.2,
                        label = paste(road_sec$value))

roads_map <- leaflet(road_sec) %>% 
             addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
             options = providerTileOptions(noWrap = TRUE)) %>%
  
                 addCircleMarkers(radius = ~0.1*value, color = ~pal(value), 
                        fillColor = ~pal(value), opacity = 0.2,
                        label = paste(road_sec$value))
roads_map
```

## Roads pic identification

```{r}
road_sec$numero= 1:5749

library(plotly)

fg1 <- plot_ly(x=~road_sec$sensor_time, y=~road_sec$value, alpha = 0.4,
              mode = 'lines', text = road_sec$numero)

fg1
```


```{r}
road_sec$value

library(quantmod)
maxindex=findPeaks(road_sec$value[30:200])
minindex=findValleys(road_sec$value[30:200])

minmax=data.frame(value=road_sec$value)
minmax$min=0
minmax$max=0

minmax$min[minindex]=1
minmax$max[maxindex]=1


#ICI


```




### Fields pre-processing

```{r}
names(fields)[1] <- "date_time"
names(fields)[2] <- "date_gnss"
names(fields)[3] <- "time_gnss"
names(fields)[4] <- "latitude"
names(fields)[5] <- "longitude"
names(fields)[6] <- "speed"
names(fields)[7] <- "field_id"
names(fields)[8] <- "soil_type"

fields$date_time <- as.POSIXct(fields$date_time)

fields$speed <- gsub(",", ".", fields$speed) %>%
                as.numeric()
fields$longitude <- gsub(",", ".", fields$longitude) %>%
                as.numeric()
fields
```

```{r}
min(fields$date_time);max(fields$date_time) # Aller/retours considerated - not informative !!!
```

### Fields query fun 

```{r}
# Subsetting the roads dataset 
fields_querer <- function (fieldId){ # Oui oui querer 
  field <- fields[fields$field_id == fieldId,]

  # Using logs subset to subset sensor data 
  subseted_sensor <- sensor_df[sensor_df$sensor_time >= min(field$date_time) &
                          sensor_df$sensor_time <= max(field$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- subseted_sensor
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > field$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = field$latitude[j]
      subset_sensor$long[i] = field$longitude[j]
      subset_sensor$vitesse[i] = field$speed[j]
      subset_sensor$field_id[i] = field$field_id[j]
      subset_sensor$soil_type[i] = field$soil_type[j]
      print(i) #debugging tool, if needed !!!
  }
  return(subset_sensor)
}

def_field <- fields_querer(1) # Querying field 1 

min(def_field$value);max(def_field$value)
```

### Mapping

```{r}
library(viridis)
library(leaflet)
domain <- range(def_field$value)

# make palette
pal <- colorNumeric(palette = viridis(3), domain = domain)
```

 
```{r}

map <- leaflet(def_field) %>% addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
                      options = providerTileOptions(noWrap = TRUE)) %>%
       addCircleMarkers(radius = ~(value-330), color = ~pal(value), 
                        fillColor = ~pal(value), opacity = 0.2,
                        label = paste0(def_field$value, " - " ,def_field$soil_type))
       
map
```


## Plot_ly 

```{r}
library(plotly)
mysensor_df$date_time <- as.POSIXct(mysensor_df$date_time)
```

```{r}
fg <- plot_ly(x=~mysensor_df$date_time, y=mysensor_df$value, alpha = 0.4,
              mode = 'markers', text = paste("days from today"))
fg
```

```{r message=FALSE, warning=FALSE}
my_parcelles <- read_csv("P2/GIS_parcelles.csv");my_parcelles
roads <- fread("P2/roads_p2.csv");roads
```

```{r}
names(my_parcelles)[1] <- "date_time"
names(roads)[1] <- "date_time"
  
names(my_parcelles)[2] <- "date_gnss"
names(roads)[2] <- "date_gnss"
  
names(my_parcelles)[3] <- "time_gnss"
names(roads)[3] <- "time_gnss"

names(my_parcelles)[4] <- "time_gnss"
names(roads)[4] <- "time_gnss"

names(my_parcelles)[5] <- "time_gnss"
names(roads)[5] <- "time_gnss"

names(my_parcelles)[6] <- "time_gnss"
names(roads)[6] <- "time_gnss"

table(my_parcelles$`ID Culture`)
roads
```

```{r}
mysensor_df$date_time <- as.character(mysensor_df$date_time)
my_parcelles$date_time <- as.character(my_parcelles$date_time)
```

```{r}
join_parcelles <- merge(mysensor_df, my_parcelles, by="date_time")
table(join_parcelles$`ID Culture`)
```



```{r}
join_parcelles$date_time <- as.POSIXct(join_parcelles$date_time)

fg <- plot_ly(x=~join_parcelles$date_time, y=~join_parcelles$value, alpha = 0.4,
              colors = ~join_parcelles$`ID Culture`,
              mode = 'lines', text = paste("days from today"))
fg
```

- Min/Max locaux avec dérivés 
- XXX
- Histogramme // 2 sortes de pics 
```{r}
library(pspline)
deriv_x <- predict(sm.spline(join_parcelles$date_time, as.numeric(join_parcelles$value)), time, 1)
```


```{r}
library(xts)
d1 <- xts(splinefun(join_parcelles$date_time, join_parcelles$value)(join_parcelles$date_time, 1), join_parcelles$date_time)
sensor_df <- cbind(join_parcelles, d1)

sensor_df$value <- as.numeric(sensor_df$value)
sensor_df$date_time <- as.POSIXct(sensor_df$date_time)

fg <- plot_ly(x=~sensor_df$date_time, y=~sensor_df$value, alpha = 0.4,
              mode = 'lines', text = paste("days from today"))
fg
fg1 <- plot_ly(x=~sensor_df$date_time, y=~sensor_df$value, alpha = 0.4,
              mode = 'lines', text = paste("days from today"))

fg1
```

```{r}
roads
```


```{r}
library(pracma)
sensor_df$value <- as.numeric(sensor_df$value)
pracma::findpeaks(as.numeric(sensor_df[1:100,]$value))
```

```{r}
subset_sensor_df <- sensor_df[1:100,]

subset_sensor_df$sensor_time <- as.POSIXct(subset_sensor_df$sensor_time)
subset_sensor_df$sensor_time <- format(subset_sensor_df$sensor_time,"%Y-%m-%d %H:%M:%OS3")

fg <- plot_ly(x=~subset_sensor_df$sensor_time, y=~subset_sensor_df$value, alpha = 0.4,
              mode = 'markers', text = paste("days from today"))
fg  %>%
layout(paper_bgcolor='#5875D5',
       plot_bgcolor='#5875D5')
fg
```

- largeur pic : vitesse (intervale pic) // compensation de la perte de données due à la déformation 
- graphes de validation 

- this first step : bruit créer par le dispositif (caractériser stabilité dans le temps de ces indicateurs/ est-ce influencé par les variations d'altitudes, chngmnt de rang / aller-retour) 
   // graph maxi-amplitudes-bien conprendre leur variabilité- séparation route/parcelles-axé sur montrer la variabilité soit par type de revêtement soit par structure spatiale dans les rangs 
   // classification des valeurs par vitesses (mettre route VS parcelles) -> faire des classes de vitesses bien disjointes

- after : est-ce que intensité variation de poids générée par la charge est masquée ou pas. 




