---
title: "Carto_pneu_remedy"
author: "Ibrahima SOW"
date: "12/14/2020"
output: html_document
---


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(readr)
library(data.table)
library(stringr)
```

## Second passage
```{r}
sensor_df <- fread("P2/sensor_1.csv", header = T) 
names(sensor_df)[1] <- "sensor_id"
names(sensor_df)[2] <- "sensor_time"
names(sensor_df)[3] <- "value"
sensor_df
``` 


```{r}
sensor_df$sensor_id <- substr(sensor_df$sensor_id, 14, 14)

sensor_df$sensor_time <- substr(sensor_df$sensor_time, 15, 39)
sensor_df$sensor_time <- gsub("T", " ", sensor_df$sensor_time)

sensor_df$value <- substr(sensor_df$value, 10, 14)

sensor_df$value <- gsub("\"", "", sensor_df$value)
sensor_df$value <- gsub("}", "", sensor_df$value)

options(digits.secs = 3) 

sensor_df$sensor_time <- as.POSIXct(sensor_df$sensor_time)

sensor_df$value <- as.numeric(sensor_df$value)
  
#sensor_1_P2$sensor_time <- gsub("Z", "", sensor_1_P2$sensor_time)
sensor_df

write.csv(sensor_df, "sensor_df.csv")
```

## Importing simple log files  

```{r message=FALSE, warning=FALSE}
#simple_log_P1 <- fread("P1/simple-log.txt",  header = F)
logs <- fread("P2/simple-log.txt",  header = F)

#simple_log_P1$V1 <- substr(simple_log_P1$V1, 1, 23)
logs$V1 <- substr(logs$V1, 1, 27)

names(logs)[1] <- "date_time"
names(logs)[2] <- "date_gnss"
names(logs)[3] <- "heure_gnss"
names(logs)[4] <- "latitude"
names(logs)[5] <- "longitude"
names(logs)[6] <- "speed"

logs$date_time <-as.POSIXct(logs$date_time, format="%Y-%m-%d %H:%M:%OS")

#simple_log_P2$date_time <- format(simple_log_P2$date_time,)
logs <- logs[!is.na(logs$latitude) &
                                 !is.na(logs$longitude), ] %>%
        subset(select = -c(date_gnss, heure_gnss))
logs
```

## Roads/Fields segmentation

```{r message=FALSE, warning=FALSE}
fields <- fread("P2/fields.csv")
fields <- as.data.frame(sapply(fields, function(x) {x <- gsub("\"","",x)}))
fields
roads <- fread("P2/roads.csv")
roads <- as.data.frame(sapply(roads, function(x) {x <- gsub("\"","",x)}))
roads
```

### ROADS
#### Roads pre-processing

```{r}
names(roads)[1] <- "date_time"
names(roads)[2] <- "date_gnss"
names(roads)[3] <- "time_gnss"
names(roads)[4] <- "latitude"
names(roads)[5] <- "longitude"
names(roads)[6] <- "speed"
names(roads)[7] <- "road_sections"

roads <- as.data.frame(sapply(roads, function(x) {x <- gsub("\"","",x)}))

roads$road_sections <- gsub("portion", "", roads$road_sections) %>%
                        as.numeric()

roads$date_time <- as.POSIXct(roads$date_time)

roads
```

```{r}
roads$round <- "aller"
roads[1185:nrow(roads),8] <- "retour" # 1184 index -> début retour
roads
```

```{r}
min(roads$date_time);max(roads$date_time) # aller/retours (not that informative)
```

#### Roads query fun 
```{r}
# Segmentation par requêtes - aller 1 ici 
roads_querer <- function (section, round_type){ # OUi oui querer
  
  # Subsetting the roads dataset 
  queried_vals <- roads[roads$road_sections == 1 & roads$round=="aller",]
  
  # Using logs subset to subset sensor data 
  sensor_df_p2 <- sensor_df[sensor_df$sensor_time >= min(queried_vals$date_time) &
                          sensor_df$sensor_time <= max(queried_vals$date_time),]
  
  # Changing df names (for secure)
  subset_sensor <- sensor_df_p2
  roads_logs <- roads
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > queried_vals$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = queried_vals$latitude[j]
      subset_sensor$long[i] = queried_vals$longitude[j]
      subset_sensor$speed[i] = queried_vals$speed[j]
      subset_sensor$road_sections[i] = queried_vals$road_sections[j]
      subset_sensor$round[i] = queried_vals$round[j]
    #print(i) debugging tool, if needed 
  }
  return(subset_sensor)
}

road_1_A <- roads_querer(1, "aller")
write.csv(road_1_A, "road_1_A.csv")


road_2_A <- roads_querer(2, "aller")
write.csv(road_2_A, "road_2_A.csv")


road_3_A <- roads_querer(3, "aller")
write.csv(road_3_A, "road_3_A.csv")

road_4_A <- roads_querer(4, "aller") # Too long - don't run 
write.csv(road_4_A, "road_4_A.csv")

```
#### Roads mapping

```{r}
road_1 <- read_csv("Section_1.csv")
road_2 <- read_csv("Section_2.csv")
road_3 <- read_csv("Section_3.csv")

road_3$observations <- total_parcours$observations[nrow(road_2)+1:nrow(road_3)]
total_parcours <- rbind(road_1, road_2, road_3)
write.csv(road_2, "Section_2.csv")
total_parcours <- read_csv("total_parcours.csv") %>% subset(select = -c(X1, X1_1))

total_parcours$observations <- 1:nrow(total_parcours)
total_parcours$observations[1:2020] <- "sortie_MAS"
total_parcours$observations[2021:5540] <- "Ligne-droite_Av_Palavas"
total_parcours$observations[5541:6430] <- "Giratoire"
total_parcours$observations[6431:8190] <- "Ligne-droite_D185" 
total_parcours$observations[8191:8500] <- "Intersection" 
total_parcours$observations[8501:8780] <- "Ligne-droite_D185" 
total_parcours$observations[8781:8890] <- "Intersection" 
total_parcours$observations[8891:11720] <- "Ligne-droite_D185" 
total_parcours$observations[11721:12350] <- "Giratoire"
total_parcours$observations[12351:14330] <- "Ligne-droite_D185"
total_parcours$observations[14331:nrow(total_parcours)] <- "Ligne-droite_D185"

write.csv(total_parcours, "total_parcours.csv")
```

```{r message=FALSE, warning=FALSE}
road_X <- read_csv("road_2_A.csv")
library(viridis)
library(leaflet)
domain <- range(road_X$value)

# make palette
pal <- colorNumeric(palette = viridis(3), domain = domain)
```

 
```{r}
leaflet(road_X) %>% 
                addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
                options = providerTileOptions(noWrap = TRUE)) %>%
                setView(lat=43.5398,lng=3.8607, 14.5) %>%
                addCircleMarkers(radius = ~(value-350), color = ~pal(value), 
                                fillColor = ~pal(value), opacity = 0.2,
                                label = paste(road_X$value)) 
```

-------------------
 
Val's 

```{r}
road_sec$value
library(quantmod)
maxindex=findPeaks(road_sec$value[30:200])
minindex=findValleys(road_sec$value[30:200])
```

```{r}
minmax=data.frame(value=road_sec$value)
minmax$min=0
minmax$max=0
minmax$min[minindex]=1
minmax$max[maxindex]=1
```

-------------------

### FIELDS 
#### Fields pre-processing

#### Fields pre-processing

```{r}
names(fields)[1] <- "date_time"
names(fields)[2] <- "date_gnss"
names(fields)[3] <- "time_gnss"
names(fields)[4] <- "latitude"
names(fields)[5] <- "longitude"
names(fields)[6] <- "speed"
names(fields)[7] <- "field_id"
names(fields)[8] <- "soil_type"

fields$date_time <- as.POSIXct(fields$date_time)

fields$speed <- gsub(",", ".", fields$speed) %>%
                as.numeric()
fields$longitude <- gsub(",", ".", fields$longitude) %>%
                as.numeric()
fields
```

```{r}
min(fields$date_time);max(fields$date_time) # Aller/retours considerated - not informative !!!
```

#### Fields query fun 

```{r}
# Subsetting the roads dataset 
fields_querer <- function (fieldId){ # Oui oui querer 
  field <- fields[fields$field_id == 42,]

  # Using logs subset to subset sensor data 
  subseted_sensor <- sensor_df[sensor_df$sensor_time >= mean(field$date_time) &
                          sensor_df$sensor_time <= "2020-11-13 00:00:00.001 CET",] # 00:00:00 for subsetting 
  
  # Changing df names (for secure)
  subset_sensor <- subseted_sensor
  
  # While statement to affect lats/longs and speed to dedicated timestamps
  j=1
  for(i in 1:nrow(subset_sensor)) {
    while(subset_sensor$sensor_time[i] > field$date_time[j]) {
      j=j+1
    }
      subset_sensor$lat[i] = field$latitude[j]
      subset_sensor$long[i] = field$longitude[j]
      subset_sensor$vitesse[i] = field$speed[j]
      subset_sensor$field_id[i] = field$field_id[j]
      subset_sensor$soil_type[i] = field$soil_type[j]
      print(i) #debugging tool, if needed !!!
  }
  return(subset_sensor)
}

# field_1 <- fields_querer(1) # Querying field 1 - Field sensor data not completed here
# write.csv(field_1, "field_1.csv")

# field_43 <- fields_querer(43) # Querying field 1 
# write.csv(field_43, "field_43.csv") 


table(fields$field_id)
min(field_1$sensor_time);max(field_1$sensor_time)
```

#### Fields Mapping

```{r message=FALSE, warning=FALSE}
field_1 <- read_csv("field_1.csv") %>% subset(select = -c(X1, sensor_id))
field_43 <- read_csv("field_43.csv") %>% subset(select = -c(X1, sensor_id))

myfields <- rbind(field_1, field_43)
write.csv(myfields, "myfields.csv")
library(viridis)
library(leaflet)
library(raster)
domain <- range(field_X$value)
soil_rasters <- raster("classif_sol.tif",prefer_proj = epsg3857)
# make palette

field_X$lat <- as.numeric(field_X$lat)
field_X$long <- as.numeric(field_X$long)
pal <- colorNumeric(palette = viridis(3), domain = domain)
rasters_pal <- colorNumeric(c("#43A9F2", "#F1D674", "#F46C6A"), values(soil_rasters),na.color = "transparent")
```

```{r message=FALSE, warning=FALSE}
library(rgdal)
parcellaire <- readOGR("P2/Parcellaire_chapitre/Culture attributs.shp")

factpal2 <- colorFactor(viridis(2, option = "magma", direction = -1), larzats$ID.Culture, reverse = T) 

larzats <- parcellaire[parcellaire$Parcella_1=="Larzat",] %>% spTransform(CRS("+proj=longlat +datum=WGS84"))
# lat=43.5483,lng=3.8437, 17 parcelles 

leaflet(field_X) %>% 
                addProviderTiles(providers$CartoDB.DarkMatterNoLabels,
                      options = providerTileOptions(noWrap = TRUE),  group = "Basic Layer(default)") %>%
                setView(lat=43.5483,lng=3.8437, 17) %>%
  
                leaflet::addPolygons(data=larzats,stroke=TRUE,color = "white",
                                     fillColor = ~factpal2(larzats$ID.Culture), opacity = 1,
                                     group = "Parcellaire") %>%
  
                addCircleMarkers(lng = ~long, lat = ~lat,radius = ~(value-350), color = ~pal(value), 
                        fillColor = ~pal(value), opacity = 0.2,
                        label = paste0(field_X$value, " - " ,field_X$soil_type), group = "Values") %>%
  
                addRasterImage(soil_rasters, colors = rasters_pal, opacity = 0.8, group = "Soil types") %>%
  
                addLegend(position = "topright",colors = c("#43A9F2", "#F1D674", "#F46C6A"),
                         labels = c("Argileux","Moyen","Caillouteux"), opacity = 0.8,title = "Soil type classification", 
                          group = "Soil types") %>%
                addLayersControl(baseGroups = c("Basic Layer (default)"),
                                 overlayGroups = c("Values","Soil types", "Parcellaire"),
                                 position = "topleft",options = layersControlOptions(collapsed = T)
  )

```

## Plotly
```{r}
fg <- plot_ly(x=~minmax$time, y=minmax$value, alpha = 0.4,
               text = paste(minmax$id, "  ", minmax$id_pic), color=as.character(minmax$id_pic))
fg
```


### Analyse stats 

```{r}
field_1_indics <- fread("indicateurs_field1.csv", sep = ",");field_1_indics
field_1_indics <- data.frame(lapply(field_1_indics, function(x) {
                  gsub("\"\"", " ", x)
             })) %>% subset(select = -c(X..largeur_sec...))


names(field_1_indics)[1] <- "id_pic"
names(field_1_indics)[2] <- "soil_type"
names(field_1_indics)[3] <- "speed"
names(field_1_indics)[4] <- "ming_value"
names(field_1_indics)[5] <- "ming_time"
names(field_1_indics)[6] <- "max_value"
names(field_1_indics)[7] <- "max_time"
names(field_1_indics)[8] <- "mind_value"
names(field_1_indics)[9] <- "mind_time"
names(field_1_indics)[10] <- "amplitude"
names(field_1_indics)[11] <- "largeur"
field_1_indics

```
```{r}
# Automation failed
# mycols <- c("ming_value","max_time", "mind_time")
# field_1_indics[mycols] <- lapply(field_1_indics[mycols], as.POSIXct)
options(digits.secs = 3) 
field_1_indics$ming_time <- as.POSIXct(field_1_indics$ming_time, format="%Y-%m-%d %H:%M:%OS")
field_1_indics$max_time <- as.POSIXct(field_1_indics$max_time, format="%Y-%m-%d %H:%M:%OS")
field_1_indics$mind_time <- as.POSIXct(field_1_indics$mind_time, format="%Y-%m-%d %H:%M:%OS")

field_1_indics$id_pic <- gsub("\"", "", field_1_indics$id_pic)
field_1_indics$largeur <- gsub("\"", "", field_1_indics$largeur)

mycols <- c("id_pic","speed","ming_value", "max_value", "mind_value","amplitude", "largeur")
field_1_indics[mycols] <- lapply(field_1_indics[mycols], as.numeric)
r_fields_inds <- field_1_indics[-36,] %>% subset(select = -c(ming_time, max_time,mind_time))

```

```{r}
library(FactoMineR)
library(factoextra)

res.pca <- PCA(r_fields_inds, quali.sup = 2, quanti.sup = c(1))
# fviz_pca_var(res.pca)
```

```{r}
lm_mod <- lm(max_value ~.,field_1_indics)
summary(lm_mod)
```

```{r}
shapiro.test(lm_mod$residuals)
shapiro.test(field_1_indics$max_value)
```

```{r}
#bartlett.test(lm_mod$residuals ~ soil_type, data = field_1_indics)
bartlett.test(max_value ~ soil_type, data = field_1_indics)
```


```{r}
res <- var.test(max_value ~ soil_type, data = field_1_indics)
res
```

#### Stats routes
```{r}
road2_indics <- fread("indicateurs_road2_tests.csv", sep = ",");road2_indics
```

```{r}
road2_indics <- data.frame(lapply(road2_indics, function(x) {
                  gsub("\"\"", " ", x)
             }));road2_indics

names(road2_indics)[1] <- "id_pic"
names(road2_indics)[2] <- "speed"
names(road2_indics)[3] <- "soil_type"
names(road2_indics)[4] <- "ming_value"
names(road2_indics)[5] <- "ming_time"
names(road2_indics)[6] <- "max_value"
names(road2_indics)[7] <- "max_time"
names(road2_indics)[8] <- "mind_value"
names(road2_indics)[9] <- "mind_time"
names(road2_indics)[10] <- "amplitude"
names(road2_indics)[11] <- "largeur"
road2_indics

```

```{r}
road2_indics <- road2_indics[,c("id_pic", "soil_type", "speed", "ming_value", "ming_time", "max_value", 
                                "max_time", "mind_value", "mind_time", "amplitude", "largeur")]

options(digits.secs = 3) 
road2_indics$ming_time <- as.POSIXct(road2_indics$ming_time, format="%Y-%m-%d %H:%M:%OS")
road2_indics$max_time <- as.POSIXct(road2_indics$max_time, format="%Y-%m-%d %H:%M:%OS")
road2_indics$mind_time <- as.POSIXct(road2_indics$mind_time, format="%Y-%m-%d %H:%M:%OS")

road2_indics$id_pic <- gsub("\"", "", road2_indics$id_pic)
road2_indics$largeur <- gsub("\"", "", road2_indics$largeur)

mycols <- c("id_pic","speed","ming_value", "max_value", "mind_value","amplitude", "largeur")
road2_indics[mycols] <- lapply(road2_indics[mycols], as.numeric)
r_road2_inds <- subset(road2_indics, select = -c(ming_time, max_time,mind_time))
r_road2_inds
```

## Binding stats roads-fields 
```{r}
my_stats_df <- rbind(r_road2_inds, r_fields_inds)
```

```{r}
res.pca <- PCA(my_stats_df, quali.sup = 2, quanti.sup = c(1))
```

```{r}
lm_mod <- lm(max_value ~ soil_type,my_stats_df)
summary(lm_mod)
```


```{r}
shapiro.test(lm_mod$residuals)
shapiro.test(my_stats_df$max_value)
```

```{r}
#bartlett.test(lm_mod$residuals ~ soil_type, data = field_1_indics)
bartlett.test(max_value ~ soil_type, data = my_stats_df)
```

```{r}
table(my_stats_df$soil_type)
```


```{r}
res <- var.test(max_value, soil_type, data = my_stats_df)
res
```

## Comments and suggestions 

- Min/Max locaux avec dérivés 
- XXX
- Histogramme // 2 sortes de pics 


- largeur pic : vitesse (intervale pic) // compensation de la perte de données due à la déformation 
- graphes de validation 

- this first step : bruit créer par le dispositif (caractériser stabilité dans le temps de ces indicateurs/ est-ce influencé par les variations d'altitudes, chngmnt de rang / aller-retour) 
   // graph maxi-amplitudes-bien conprendre leur variabilité- séparation route/parcelles-axé sur montrer la variabilité soit par type de revêtement soit par structure spatiale dans les rangs 
   // classification des valeurs par vitesses (mettre route VS parcelles) -> faire des classes de vitesses bien disjointes

- after : est-ce que intensité variation de poids générée par la charge est masquée ou pas. 




